{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as core from '@opentelemetry/core';\nimport { OTLP_SPAN_KIND_MAPPING, opentelemetryProto } from './types';\nvar MAX_INTEGER_VALUE = 2147483647;\nvar MIN_INTEGER_VALUE = -2147483648;\n/**\n * Converts attributes to KeyValue array\n * @param attributes\n */\n\nexport function toCollectorAttributes(attributes) {\n  return Object.keys(attributes).map(function (key) {\n    return toCollectorAttributeKeyValue(key, attributes[key]);\n  });\n}\n/**\n * Converts array of unknown value to ArrayValue\n * @param values\n */\n\nexport function toCollectorArrayValue(values) {\n  return {\n    values: values.map(function (value) {\n      return toCollectorAnyValue(value);\n    })\n  };\n}\n/**\n * Converts attributes to KeyValueList\n * @param attributes\n */\n\nexport function toCollectorKeyValueList(attributes) {\n  return {\n    values: toCollectorAttributes(attributes)\n  };\n}\n/**\n * Converts key and unknown value to KeyValue\n * @param value event value\n */\n\nexport function toCollectorAttributeKeyValue(key, value) {\n  var anyValue = toCollectorAnyValue(value);\n  return {\n    key: key,\n    value: anyValue\n  };\n}\n/**\n * Converts unknown value to AnyValue\n * @param value\n */\n\nexport function toCollectorAnyValue(value) {\n  var anyValue = {};\n\n  if (typeof value === 'string') {\n    anyValue.stringValue = value;\n  } else if (typeof value === 'boolean') {\n    anyValue.boolValue = value;\n  } else if (typeof value === 'number' && value <= MAX_INTEGER_VALUE && value >= MIN_INTEGER_VALUE && Number.isInteger(value)) {\n    anyValue.intValue = value;\n  } else if (typeof value === 'number') {\n    anyValue.doubleValue = value;\n  } else if (Array.isArray(value)) {\n    anyValue.arrayValue = toCollectorArrayValue(value);\n  } else if (value) {\n    anyValue.kvlistValue = toCollectorKeyValueList(value);\n  }\n\n  return anyValue;\n}\n/**\n *\n * Converts events\n * @param events array of events\n */\n\nexport function toCollectorEvents(timedEvents) {\n  return timedEvents.map(function (timedEvent) {\n    var timeUnixNano = core.hrTimeToNanoseconds(timedEvent.time);\n    var name = timedEvent.name;\n    var attributes = toCollectorAttributes(timedEvent.attributes || {});\n    var droppedAttributesCount = 0;\n    var protoEvent = {\n      timeUnixNano: timeUnixNano,\n      name: name,\n      attributes: attributes,\n      droppedAttributesCount: droppedAttributesCount\n    };\n    return protoEvent;\n  });\n}\n/**\n * Converts links\n * @param span\n * @param useHex - if ids should be kept as hex without converting to base64\n */\n\nfunction toCollectorLinks(span, useHex) {\n  return span.links.map(function (link) {\n    var protoLink = {\n      traceId: useHex ? link.context.traceId : core.hexToBase64(link.context.traceId),\n      spanId: useHex ? link.context.spanId : core.hexToBase64(link.context.spanId),\n      attributes: toCollectorAttributes(link.attributes || {}),\n      droppedAttributesCount: 0\n    };\n    return protoLink;\n  });\n}\n/**\n * Converts span\n * @param span\n * @param useHex - if ids should be kept as hex without converting to base64\n */\n\n\nexport function toCollectorSpan(span, useHex) {\n  return {\n    traceId: useHex ? span.spanContext().traceId : core.hexToBase64(span.spanContext().traceId),\n    spanId: useHex ? span.spanContext().spanId : core.hexToBase64(span.spanContext().spanId),\n    parentSpanId: span.parentSpanId ? useHex ? span.parentSpanId : core.hexToBase64(span.parentSpanId) : undefined,\n    traceState: toCollectorTraceState(span.spanContext().traceState),\n    name: span.name,\n    kind: toCollectorKind(span.kind),\n    startTimeUnixNano: core.hrTimeToNanoseconds(span.startTime),\n    endTimeUnixNano: core.hrTimeToNanoseconds(span.endTime),\n    attributes: toCollectorAttributes(span.attributes),\n    droppedAttributesCount: 0,\n    events: toCollectorEvents(span.events),\n    droppedEventsCount: 0,\n    status: toCollectorStatus(span.status),\n    links: toCollectorLinks(span, useHex),\n    droppedLinksCount: 0\n  };\n}\n/**\n * Converts status\n * @param status\n */\n\nexport function toCollectorStatus(status) {\n  var spanStatus = {\n    code: status.code\n  };\n\n  if (typeof status.message !== 'undefined') {\n    spanStatus.message = status.message;\n  }\n\n  return spanStatus;\n}\n/**\n * Converts resource\n * @param resource\n * @param additionalAttributes\n */\n\nexport function toCollectorResource(resource, additionalAttributes) {\n  if (additionalAttributes === void 0) {\n    additionalAttributes = {};\n  }\n\n  var attr = Object.assign({}, additionalAttributes, resource ? resource.attributes : {});\n  var resourceProto = {\n    attributes: toCollectorAttributes(attr),\n    droppedAttributesCount: 0\n  };\n  return resourceProto;\n}\n/**\n * Converts span kind\n * @param kind\n */\n\nexport function toCollectorKind(kind) {\n  var collectorKind = OTLP_SPAN_KIND_MAPPING[kind];\n  return typeof collectorKind === 'number' ? collectorKind : opentelemetryProto.trace.v1.Span.SpanKind.SPAN_KIND_UNSPECIFIED;\n}\n/**\n * Converts traceState\n * @param traceState\n */\n\nexport function toCollectorTraceState(traceState) {\n  if (!traceState) return undefined;\n  return traceState.serialize();\n}\n/**\n * Prepares trace service request to be sent to collector\n * @param spans spans\n * @param collectorExporterBase\n * @param useHex - if ids should be kept as hex without converting to base64\n */\n\nexport function toOTLPExportTraceServiceRequest(spans, collectorTraceExporterBase, useHex) {\n  var groupedSpans = groupSpansByResourceAndLibrary(spans);\n  var additionalAttributes = Object.assign({}, collectorTraceExporterBase.attributes);\n  return {\n    resourceSpans: toCollectorResourceSpans(groupedSpans, additionalAttributes, useHex)\n  };\n}\n/**\n * Takes an array of spans and groups them by resource and instrumentation\n * library\n * @param spans spans\n */\n\nexport function groupSpansByResourceAndLibrary(spans) {\n  return spans.reduce(function (spanMap, span) {\n    //group by resource\n    var resourceSpans = spanMap.get(span.resource);\n\n    if (!resourceSpans) {\n      resourceSpans = new Map();\n      spanMap.set(span.resource, resourceSpans);\n    } //group by instrumentation library\n\n\n    var libSpans = resourceSpans.get(span.instrumentationLibrary);\n\n    if (!libSpans) {\n      libSpans = new Array();\n      resourceSpans.set(span.instrumentationLibrary, libSpans);\n    }\n\n    libSpans.push(span);\n    return spanMap;\n  }, new Map());\n}\n/**\n * Convert to InstrumentationLibrarySpans\n * @param instrumentationLibrary\n * @param spans\n * @param useHex - if ids should be kept as hex without converting to base64\n */\n\nfunction toCollectorInstrumentationLibrarySpans(instrumentationLibrary, spans, useHex) {\n  return {\n    spans: spans.map(function (span) {\n      return toCollectorSpan(span, useHex);\n    }),\n    instrumentationLibrary: instrumentationLibrary\n  };\n}\n/**\n * Returns a list of resource spans which will be exported to the collector\n * @param groupedSpans\n * @param baseAttributes\n * @param useHex - if ids should be kept as hex without converting to base64\n */\n\n\nfunction toCollectorResourceSpans(groupedSpans, baseAttributes, useHex) {\n  return Array.from(groupedSpans, function (_a) {\n    var resource = _a[0],\n        libSpans = _a[1];\n    return {\n      resource: toCollectorResource(resource, baseAttributes),\n      instrumentationLibrarySpans: Array.from(libSpans, function (_a) {\n        var instrumentationLibrary = _a[0],\n            spans = _a[1];\n        return toCollectorInstrumentationLibrarySpans(instrumentationLibrary, spans, useHex);\n      })\n    };\n  });\n} //# sourceMappingURL=transform.js.map","map":null,"metadata":{},"sourceType":"module"}