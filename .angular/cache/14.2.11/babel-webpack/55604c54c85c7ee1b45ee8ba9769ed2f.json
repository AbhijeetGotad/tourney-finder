{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nimport { isSpanContextValid, isValidSpanId, isValidTraceId, trace, TraceFlags } from '@opentelemetry/api';\nimport { isTracingSuppressed } from '@opentelemetry/core';\nimport { B3_DEBUG_FLAG_KEY } from './common';\nimport { B3_CONTEXT_HEADER } from './constants';\nvar B3_CONTEXT_REGEX = /((?:[0-9a-f]{16}){1,2})-([0-9a-f]{16})(?:-([01d](?![0-9a-f])))?(?:-([0-9a-f]{16}))?/;\nvar PADDING = '0'.repeat(16);\nvar SAMPLED_VALUES = new Set(['d', '1']);\nvar DEBUG_STATE = 'd';\n\nfunction convertToTraceId128(traceId) {\n  return traceId.length === 32 ? traceId : \"\" + PADDING + traceId;\n}\n\nfunction convertToTraceFlags(samplingState) {\n  if (samplingState && SAMPLED_VALUES.has(samplingState)) {\n    return TraceFlags.SAMPLED;\n  }\n\n  return TraceFlags.NONE;\n}\n/**\n * Propagator for the B3 single-header HTTP format.\n * Based on: https://github.com/openzipkin/b3-propagation\n */\n\n\nvar B3SinglePropagator =\n/** @class */\nfunction () {\n  function B3SinglePropagator() {}\n\n  B3SinglePropagator.prototype.inject = function (context, carrier, setter) {\n    var spanContext = trace.getSpanContext(context);\n    if (!spanContext || !isSpanContextValid(spanContext) || isTracingSuppressed(context)) return;\n    var samplingState = context.getValue(B3_DEBUG_FLAG_KEY) || spanContext.traceFlags & 0x1;\n    var value = spanContext.traceId + \"-\" + spanContext.spanId + \"-\" + samplingState;\n    setter.set(carrier, B3_CONTEXT_HEADER, value);\n  };\n\n  B3SinglePropagator.prototype.extract = function (context, carrier, getter) {\n    var header = getter.get(carrier, B3_CONTEXT_HEADER);\n    var b3Context = Array.isArray(header) ? header[0] : header;\n    if (typeof b3Context !== 'string') return context;\n    var match = b3Context.match(B3_CONTEXT_REGEX);\n    if (!match) return context;\n\n    var _a = __read(match, 4),\n        extractedTraceId = _a[1],\n        spanId = _a[2],\n        samplingState = _a[3];\n\n    var traceId = convertToTraceId128(extractedTraceId);\n    if (!isValidTraceId(traceId) || !isValidSpanId(spanId)) return context;\n    var traceFlags = convertToTraceFlags(samplingState);\n\n    if (samplingState === DEBUG_STATE) {\n      context = context.setValue(B3_DEBUG_FLAG_KEY, samplingState);\n    }\n\n    return trace.setSpanContext(context, {\n      traceId: traceId,\n      spanId: spanId,\n      isRemote: true,\n      traceFlags: traceFlags\n    });\n  };\n\n  B3SinglePropagator.prototype.fields = function () {\n    return [B3_CONTEXT_HEADER];\n  };\n\n  return B3SinglePropagator;\n}();\n\nexport { B3SinglePropagator }; //# sourceMappingURL=B3SinglePropagator.js.map","map":null,"metadata":{},"sourceType":"module"}