{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n\nvar _a;\n\nimport * as api from '@opentelemetry/api';\nimport { hrTimeToMicroseconds } from '@opentelemetry/core';\nimport * as zipkinTypes from './types';\nvar ZIPKIN_SPAN_KIND_MAPPING = (_a = {}, _a[api.SpanKind.CLIENT] = zipkinTypes.SpanKind.CLIENT, _a[api.SpanKind.SERVER] = zipkinTypes.SpanKind.SERVER, _a[api.SpanKind.CONSUMER] = zipkinTypes.SpanKind.CONSUMER, _a[api.SpanKind.PRODUCER] = zipkinTypes.SpanKind.PRODUCER, // When absent, the span is local.\n_a[api.SpanKind.INTERNAL] = undefined, _a);\nexport var defaultStatusCodeTagName = 'otel.status_code';\nexport var defaultStatusErrorTagName = 'error';\n/**\n * Translate OpenTelemetry ReadableSpan to ZipkinSpan format\n * @param span Span to be translated\n */\n\nexport function toZipkinSpan(span, serviceName, statusCodeTagName, statusErrorTagName) {\n  var zipkinSpan = {\n    traceId: span.spanContext().traceId,\n    parentId: span.parentSpanId,\n    name: span.name,\n    id: span.spanContext().spanId,\n    kind: ZIPKIN_SPAN_KIND_MAPPING[span.kind],\n    timestamp: hrTimeToMicroseconds(span.startTime),\n    duration: hrTimeToMicroseconds(span.duration),\n    localEndpoint: {\n      serviceName: serviceName\n    },\n    tags: _toZipkinTags(span, statusCodeTagName, statusErrorTagName),\n    annotations: span.events.length ? _toZipkinAnnotations(span.events) : undefined\n  };\n  return zipkinSpan;\n}\n/** Converts OpenTelemetry Span properties to Zipkin Tags format. */\n\nexport function _toZipkinTags(_a, statusCodeTagName, statusErrorTagName) {\n  var e_1, _b;\n\n  var attributes = _a.attributes,\n      resource = _a.resource,\n      status = _a.status,\n      droppedAttributesCount = _a.droppedAttributesCount,\n      droppedEventsCount = _a.droppedEventsCount,\n      droppedLinksCount = _a.droppedLinksCount;\n  var tags = {};\n\n  try {\n    for (var _c = __values(Object.keys(attributes)), _d = _c.next(); !_d.done; _d = _c.next()) {\n      var key = _d.value;\n      tags[key] = String(attributes[key]);\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (_d && !_d.done && (_b = _c.return)) _b.call(_c);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  }\n\n  if (status.code !== api.SpanStatusCode.UNSET) {\n    tags[statusCodeTagName] = String(api.SpanStatusCode[status.code]);\n  }\n\n  if (status.code === api.SpanStatusCode.ERROR && status.message) {\n    tags[statusErrorTagName] = status.message;\n  }\n  /* Add droppedAttributesCount as a tag */\n\n\n  if (droppedAttributesCount) {\n    tags['otel.dropped_attributes_count'] = String(droppedAttributesCount);\n  }\n  /* Add droppedEventsCount as a tag */\n\n\n  if (droppedEventsCount) {\n    tags['otel.dropped_events_count'] = String(droppedEventsCount);\n  }\n  /* Add droppedLinksCount as a tag */\n\n\n  if (droppedLinksCount) {\n    tags['otel.dropped_links_count'] = String(droppedLinksCount);\n  }\n\n  Object.keys(resource.attributes).forEach(function (name) {\n    return tags[name] = String(resource.attributes[name]);\n  });\n  return tags;\n}\n/**\n * Converts OpenTelemetry Events to Zipkin Annotations format.\n */\n\nexport function _toZipkinAnnotations(events) {\n  return events.map(function (event) {\n    return {\n      timestamp: hrTimeToMicroseconds(event.time),\n      value: event.name\n    };\n  });\n} //# sourceMappingURL=transform.js.map","map":null,"metadata":{},"sourceType":"module"}