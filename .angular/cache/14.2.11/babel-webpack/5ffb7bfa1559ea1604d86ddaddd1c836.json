{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nimport { propagation, trace, TraceFlags } from '@opentelemetry/api';\nimport { isTracingSuppressed } from '@opentelemetry/core';\nexport var UBER_TRACE_ID_HEADER = 'uber-trace-id';\nexport var UBER_BAGGAGE_HEADER_PREFIX = 'uberctx';\n/**\n * Propagates {@link SpanContext} through Trace Context format propagation.\n * {trace-id}:{span-id}:{parent-span-id}:{flags}\n * {trace-id}\n * 64-bit or 128-bit random number in base16 format.\n * Can be variable length, shorter values are 0-padded on the left.\n * Value of 0 is invalid.\n * {span-id}\n * 64-bit random number in base16 format.\n * {parent-span-id}\n * Set to 0 because this field is deprecated.\n * {flags}\n * One byte bitmap, as two hex digits.\n * Inspired by jaeger-client-node project.\n */\n\nvar JaegerPropagator =\n/** @class */\nfunction () {\n  function JaegerPropagator(config) {\n    if (typeof config === 'string') {\n      this._jaegerTraceHeader = config;\n      this._jaegerBaggageHeaderPrefix = UBER_BAGGAGE_HEADER_PREFIX;\n    } else {\n      this._jaegerTraceHeader = (config === null || config === void 0 ? void 0 : config.customTraceHeader) || UBER_TRACE_ID_HEADER;\n      this._jaegerBaggageHeaderPrefix = (config === null || config === void 0 ? void 0 : config.customBaggageHeaderPrefix) || UBER_BAGGAGE_HEADER_PREFIX;\n    }\n  }\n\n  JaegerPropagator.prototype.inject = function (context, carrier, setter) {\n    var e_1, _a;\n\n    var spanContext = trace.getSpanContext(context);\n    var baggage = propagation.getBaggage(context);\n\n    if (spanContext && isTracingSuppressed(context) === false) {\n      var traceFlags = \"0\" + (spanContext.traceFlags || TraceFlags.NONE).toString(16);\n      setter.set(carrier, this._jaegerTraceHeader, spanContext.traceId + \":\" + spanContext.spanId + \":0:\" + traceFlags);\n    }\n\n    if (baggage) {\n      try {\n        for (var _b = __values(baggage.getAllEntries()), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var _d = __read(_c.value, 2),\n              key = _d[0],\n              entry = _d[1];\n\n          setter.set(carrier, this._jaegerBaggageHeaderPrefix + \"-\" + key, encodeURIComponent(entry.value));\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n    }\n  };\n\n  JaegerPropagator.prototype.extract = function (context, carrier, getter) {\n    var e_2, _a;\n\n    var _this = this;\n\n    var _b;\n\n    var uberTraceIdHeader = getter.get(carrier, this._jaegerTraceHeader);\n    var uberTraceId = Array.isArray(uberTraceIdHeader) ? uberTraceIdHeader[0] : uberTraceIdHeader;\n    var baggageValues = getter.keys(carrier).filter(function (key) {\n      return key.startsWith(_this._jaegerBaggageHeaderPrefix + \"-\");\n    }).map(function (key) {\n      var value = getter.get(carrier, key);\n      return {\n        key: key.substring(_this._jaegerBaggageHeaderPrefix.length + 1),\n        value: Array.isArray(value) ? value[0] : value\n      };\n    });\n    var newContext = context; // if the trace id header is present and valid, inject it into the context\n\n    if (typeof uberTraceId === 'string') {\n      var spanContext = deserializeSpanContext(uberTraceId);\n\n      if (spanContext) {\n        newContext = trace.setSpanContext(newContext, spanContext);\n      }\n    }\n\n    if (baggageValues.length === 0) return newContext; // if baggage values are present, inject it into the current baggage\n\n    var currentBaggage = (_b = propagation.getBaggage(context)) !== null && _b !== void 0 ? _b : propagation.createBaggage();\n\n    try {\n      for (var baggageValues_1 = __values(baggageValues), baggageValues_1_1 = baggageValues_1.next(); !baggageValues_1_1.done; baggageValues_1_1 = baggageValues_1.next()) {\n        var baggageEntry = baggageValues_1_1.value;\n        if (baggageEntry.value === undefined) continue;\n        currentBaggage = currentBaggage.setEntry(baggageEntry.key, {\n          value: decodeURIComponent(baggageEntry.value)\n        });\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (baggageValues_1_1 && !baggageValues_1_1.done && (_a = baggageValues_1.return)) _a.call(baggageValues_1);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n\n    newContext = propagation.setBaggage(newContext, currentBaggage);\n    return newContext;\n  };\n\n  JaegerPropagator.prototype.fields = function () {\n    return [this._jaegerTraceHeader];\n  };\n\n  return JaegerPropagator;\n}();\n\nexport { JaegerPropagator };\nvar VALID_HEX_RE = /^[0-9a-f]{1,2}$/i;\n/**\n * @param {string} serializedString - a serialized span context.\n * @return {SpanContext} - returns a span context represented by the serializedString.\n **/\n\nfunction deserializeSpanContext(serializedString) {\n  var headers = decodeURIComponent(serializedString).split(':');\n\n  if (headers.length !== 4) {\n    return null;\n  }\n\n  var _a = __read(headers, 4),\n      _traceId = _a[0],\n      _spanId = _a[1],\n      flags = _a[3];\n\n  var traceId = _traceId.padStart(32, '0');\n\n  var spanId = _spanId.padStart(16, '0');\n\n  var traceFlags = VALID_HEX_RE.test(flags) ? parseInt(flags, 16) & 1 : 1;\n  return {\n    traceId: traceId,\n    spanId: spanId,\n    isRemote: true,\n    traceFlags: traceFlags\n  };\n} //# sourceMappingURL=JaegerPropagator.js.map","map":null,"metadata":{},"sourceType":"module"}